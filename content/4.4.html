<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Flujo del Programa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Tierra y Mar (neutros cálidos con acentos de azul) -->
    <!-- Application Structure Plan: Se ha diseñado una SPA (Single Page Application) para explicar las instrucciones de control de flujo (JSR, SBR, RET) a través de un sistema de navegación por pestañas o "cards" seleccionables. La interfaz se divide en dos secciones principales: una barra lateral de navegación para elegir la instrucción y un panel de contenido dinámico para mostrar la información detallada. Este diseño permite al usuario explorar de forma no lineal y enfocada, ideal para comparar conceptos técnicos de manera eficiente. -->
    <!-- Visualization & Content Choices: 1. Tarjetas de Instrucción: Se utilizan contenedores HTML estilizados para cada instrucción. Objetivo: Organizar visualmente la información y servir como puntos de interacción. Interacción: Al hacer clic en una tarjeta, se activa un estado visual (color, sombra) y se actualiza el panel de contenido. Justificación: Un sistema de tarjetas es intuitivo y estéticamente agradable. 2. Panel de Contenido Dinámico: Un único contenedor que cambia su contenido en función de la selección del usuario. Objetivo: Proporcionar información detallada y estructurada sin sobrecargar la interfaz. Interacción: El contenido textual cambia dinámicamente con JavaScript. Justificación: Mantiene el diseño limpio, presentando solo la información relevante en un momento dado. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f4;
        }
        .instruction-card {
            transition: all 0.3s ease-in-out;
            border-width: 2px;
            border-color: #e7e5e4;
        }
        .instruction-card.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .content-panel {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }
        .content-panel.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="text-stone-800">

    <div class="container mx-auto px-4 py-8 md:py-12">

        <header class="text-center mb-12">
            <h1 class="text-3xl md:text-4xl font-bold text-stone-900">Control de Flujo del Programa</h1>
            <p class="mt-2 text-lg text-stone-600 max-w-3xl mx-auto">Comprende cómo organizar tu programa de PLC en bloques de código modulares para mejorar la eficiencia y la legibilidad.</p>
        </header>

        <main class="lg:flex lg:space-x-8">
            <!-- Navigation Sidebar -->
            <nav class="bg-white p-6 rounded-lg shadow-md border border-stone-200 mb-8 lg:mb-0 lg:w-1/3 h-fit">
                <h2 class="font-bold text-xl text-stone-900 mb-4">Instrucciones</h2>
                <div class="space-y-4">
                    <div class="instruction-card bg-white p-6 rounded-lg shadow-sm cursor-pointer text-center" data-target="intro">
                        <h3 class="font-bold text-xl text-stone-800">Introducción</h3>
                        <p class="text-sm text-stone-600 mt-1">¿Qué es el Control de Flujo?</p>
                    </div>
                    <div class="instruction-card bg-white p-6 rounded-lg shadow-sm cursor-pointer text-center" data-target="jsr">
                        <h3 class="font-bold text-3xl text-stone-800">JSR</h3>
                        <p class="text-sm text-stone-600 mt-1">Jump to Subroutine</p>
                    </div>
                    <div class="instruction-card bg-white p-6 rounded-lg shadow-sm cursor-pointer text-center" data-target="sbr">
                        <h3 class="font-bold text-3xl text-stone-800">SBR</h3>
                        <p class="text-sm text-stone-600 mt-1">Subroutine</p>
                    </div>
                    <div class="instruction-card bg-white p-6 rounded-lg shadow-sm cursor-pointer text-center" data-target="ret">
                        <h3 class="font-bold text-3xl text-stone-800">RET</h3>
                        <p class="text-sm text-stone-600 mt-1">Return</p>
                    </div>
                </div>
            </nav>

            <!-- Main Content Panel -->
            <section class="flex-1 bg-white p-8 rounded-lg shadow-md border border-stone-200">
                <div id="intro-panel" class="content-panel active">
                    <h2 class="font-bold text-2xl text-blue-600 mb-2">Introducción al Control de Flujo</h2>
                    <p class="text-stone-600 mb-4">El control de flujo del programa es la capacidad de mover la ejecución del programa de una rutina a otra. Esto permite organizar el código en bloques modulares y reutilizables, lo que facilita la lectura, el mantenimiento y la depuración de programas complejos.</p>
                    <div class="bg-stone-100 p-6 rounded-lg border border-stone-200 text-stone-700">
                        <p class="mb-2"><span class="font-bold">Programación Estructurada:</span> El uso de subrutinas es un pilar de la programación estructurada en PLC. En lugar de tener todo el código en una sola rutina principal, se divide en pequeñas secciones lógicas que se llaman según sea necesario. Esto previene la duplicación de código y mejora la organización.</p>
                    </div>
                </div>

                <div id="jsr-panel" class="content-panel">
                    <h2 class="font-bold text-2xl text-blue-600 mb-2">Instrucción JSR (Jump to Subroutine)</h2>
                    <p class="text-stone-600 mb-4">La instrucción **JSR** es la llamada a una subrutina. Cuando el peldaño que la precede es lógicamente verdadero, la ejecución del programa se transfiere a la subrutina especificada. Una vez que la subrutina completa su ciclo, el programa regresa y continúa su ejecución en el peldaño inmediatamente siguiente al JSR.</p>
                    <h3 class="font-semibold text-lg text-stone-800 mt-4 mb-2">Ejemplo en Ladder:</h3>
                    <div class="bg-stone-100 p-4 rounded-lg">
                        <pre class="font-mono text-sm text-stone-800">|--[XIC Start_Motor]--[JSR Motor_Subroutine]--|</pre>
                        <p class="text-xs text-stone-500 mt-2">Cuando `Start_Motor` se activa, el programa ejecuta el código en la subrutina `Motor_Subroutine`.</p>
                    </div>
                </div>

                <div id="sbr-panel" class="content-panel">
                    <h2 class="font-bold text-2xl text-blue-600 mb-2">Instrucción SBR (Subroutine)</h2>
                    <p class="text-stone-600 mb-4">La instrucción **SBR** marca el inicio de una subrutina. Esta instrucción se coloca al principio de una rutina de programa que se va a llamar desde otra rutina (generalmente la principal) usando una instrucción `JSR`. No necesita ninguna condición de habilitación.</p>
                    <h3 class="font-semibold text-lg text-stone-800 mt-4 mb-2">Ejemplo en Ladder:</h3>
                    <div class="bg-stone-100 p-4 rounded-lg">
                        <pre class="font-mono text-sm text-stone-800">|--[SBR]--|</pre>
                        <pre class="font-mono text-sm text-stone-800 mt-2">|--[XIC Button_A]--(--OTE Light_A--)--|</pre>
                        <p class="text-xs text-stone-500 mt-2">Este es el primer peldaño de la subrutina. La ejecución comienza aquí cuando se llama a esta subrutina.</p>
                    </div>
                </div>
                
                <div id="ret-panel" class="content-panel">
                    <h2 class="font-bold text-2xl text-blue-600 mb-2">Instrucción RET (Return)</h2>
                    <p class="text-stone-600 mb-4">La instrucción **RET** marca el final de una subrutina. Cuando el programa llega a esta instrucción, regresa al peldaño inmediatamente posterior a la instrucción `JSR` que la llamó. Una subrutina puede tener múltiples instrucciones `RET`, lo que permite regresar al programa principal desde diferentes puntos lógicos.</p>
                    <h3 class="font-semibold text-lg text-stone-800 mt-4 mb-2">Ejemplo en Ladder:</h3>
                    <div class="bg-stone-100 p-4 rounded-lg">
                        <pre class="font-mono text-sm text-stone-800">|--[XIC Overheat_Sensor]--[RET]--|</pre>
                        <pre class="font-mono text-sm text-stone-800 mt-2">|--[RET]--|</pre>
                        <p class="text-xs text-stone-500 mt-2">El programa regresa a la rutina principal si el sensor se activa o al llegar al final de la subrutina.</p>
                    </div>
                </div>
            </section>
        </main>

        <footer class="mt-12 flex flex-col md:flex-row gap-4 justify-between items-center">
            <a href="5.1.html" class="bg-blue-600 text-white px-6 py-3 rounded-lg shadow hover:bg-blue-700 font-semibold transition">Continuar con el siguiente tema</a>
            <a href="/temario.html" class="bg-stone-100 text-blue-600 px-6 py-3 rounded-lg shadow hover:bg-blue-200 font-semibold transition">Regresar a la página principal</a>
        </footer>

        <div class="w-full text-center mt-6 text-stone-500 text-sm font-medium">Generado con apoyo de Google Gemini por Jesus Armando Tapia Gallegos MTDE</div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const instructionCards = document.querySelectorAll('.instruction-card');
            const contentPanels = document.querySelectorAll('.content-panel');
            const initialPanel = document.getElementById('intro-panel');

            function updateDisplay(targetId) {
                contentPanels.forEach(panel => panel.classList.remove('active'));
                const targetPanel = document.getElementById(targetId);
                if (targetPanel) {
                    targetPanel.classList.add('active');
                } else {
                    initialPanel.classList.add('active');
                }
            }

            instructionCards.forEach(card => {
                card.addEventListener('click', () => {
                    instructionCards.forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    const targetId = card.dataset.target + '-panel';
                    updateDisplay(targetId);
                });
            });

            // Set a default state to the initial panel on page load
            updateDisplay('intro-panel');
            document.querySelector('.instruction-card[data-target="intro"]').classList.add('active');
        });
    </script>

</body>
</html>
